<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Graph API - Reflow Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the Reflow workflow automation platform">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Reflow Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="creating-and-managing-graphs"><a class="header" href="#creating-and-managing-graphs">Creating and Managing Graphs</a></h1>
<p>This guide covers the core APIs for creating, modifying, and managing Reflow graphs.</p>
<h2 id="graph-creation"><a class="header" href="#graph-creation">Graph Creation</a></h2>
<h3 id="basic-graph-creation"><a class="header" href="#basic-graph-creation">Basic Graph Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{Graph, PortType};
use std::collections::HashMap;
use serde_json::json;

// Create a new graph
let mut graph = Graph::new("MyWorkflow", false, None);

// Create with case sensitivity enabled
let mut case_sensitive_graph = Graph::new("CaseSensitive", true, None);

// Create with initial properties
let properties = HashMap::from([
    ("description".to_string(), json!("Data processing workflow")),
    ("version".to_string(), json!("1.0.0")),
    ("author".to_string(), json!("John Doe"))
]);
let mut graph_with_props = Graph::new("WorkflowV1", false, Some(properties));
<span class="boring">}</span></code></pre></pre>
<h3 id="graph-with-history-tracking"><a class="header" href="#graph-with-history-tracking">Graph with History Tracking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create graph with unlimited history
let (mut graph, mut history) = Graph::with_history();

// Create graph with limited history (recommended for production)
let (mut graph, mut history) = Graph::with_history_and_limit(100);
<span class="boring">}</span></code></pre></pre>
<h2 id="node-management"><a class="header" href="#node-management">Node Management</a></h2>
<h3 id="adding-nodes"><a class="header" href="#adding-nodes">Adding Nodes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic node addition
graph.add_node("data_source", "FileReader", None);

// Node with position metadata
let metadata = HashMap::from([
    ("x".to_string(), json!(100)),
    ("y".to_string(), json!(200))
]);
graph.add_node("processor", "DataProcessor", Some(metadata));

// Node with comprehensive metadata
let rich_metadata = HashMap::from([
    ("x".to_string(), json!(300)),
    ("y".to_string(), json!(150)),
    ("label".to_string(), json!("CSV Parser")),
    ("color".to_string(), json!("#3498db")),
    ("estimated_time".to_string(), json!(2.5)),
    ("resources".to_string(), json!({
        "memory": 128,
        "cpu": 0.5
    })),
    ("configuration".to_string(), json!({
        "delimiter": ",",
        "has_header": true
    }))
]);
graph.add_node("csv_parser", "CSVParser", Some(rich_metadata));
<span class="boring">}</span></code></pre></pre>
<h3 id="node-retrieval"><a class="header" href="#node-retrieval">Node Retrieval</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get node reference
if let Some(node) = graph.get_node("processor") {
    println!("Node component: {}", node.component);
    if let Some(metadata) = &amp;node.metadata {
        println!("Node metadata: {:?}", metadata);
    }
}

// Get mutable node reference
if let Some(node) = graph.get_node_mut("processor") {
    // Modify node directly (not recommended - use set_node_metadata instead)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="updating-node-metadata"><a class="header" href="#updating-node-metadata">Updating Node Metadata</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update metadata (merges with existing)
let updates = HashMap::from([
    ("color".to_string(), json!("#e74c3c")),
    ("priority".to_string(), json!("high"))
]);
graph.set_node_metadata("processor", updates);

// Clear specific metadata field by setting to null
let clear_color = HashMap::from([
    ("color".to_string(), json!(null))
]);
graph.set_node_metadata("processor", clear_color);
<span class="boring">}</span></code></pre></pre>
<h3 id="node-removal"><a class="header" href="#node-removal">Node Removal</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remove node (automatically removes all connections)
graph.remove_node("old_processor");
<span class="boring">}</span></code></pre></pre>
<h3 id="node-renaming"><a class="header" href="#node-renaming">Node Renaming</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rename node (updates all references)
graph.rename_node("old_name", "new_name");
<span class="boring">}</span></code></pre></pre>
<h2 id="connection-management"><a class="header" href="#connection-management">Connection Management</a></h2>
<h3 id="creating-connections"><a class="header" href="#creating-connections">Creating Connections</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic connection
graph.add_connection("source", "output", "processor", "input", None);

// Connection with metadata
let conn_metadata = HashMap::from([
    ("weight".to_string(), json!(0.8)),
    ("priority".to_string(), json!("high")),
    ("buffer_size".to_string(), json!(1024))
]);
graph.add_connection("processor", "output", "sink", "input", Some(conn_metadata));
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-queries"><a class="header" href="#connection-queries">Connection Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get specific connection
if let Some(connection) = graph.get_connection("source", "output", "processor", "input") {
    println!("Connection metadata: {:?}", connection.metadata);
}

// Get all connections for a node
let incoming = graph.get_incoming_connections("processor");
for (source_node, source_port, connection) in incoming {
    println!("Input from {}:{}", source_node, source_port);
}

let outgoing = graph.get_outgoing_connections("processor");
for (target_node, target_port, connection) in outgoing {
    println!("Output to {}:{}", target_node, target_port);
}

// Get connections for specific port
let port_incoming = graph.get_incoming_connections_for_port("processor", "input");
let port_outgoing = graph.get_outgoing_connections_for_port("processor", "output");
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-analysis"><a class="header" href="#connection-analysis">Connection Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if nodes are connected
if graph.are_nodes_connected("source", "processor") {
    println!("Nodes are connected");
}

// Check specific port connections
if graph.are_ports_connected("source", "output", "processor", "input") {
    println!("Ports are connected");
}

// Get connection degrees
let (in_degree, out_degree) = graph.get_connection_degree("processor");
println!("Node has {} inputs and {} outputs", in_degree, out_degree);

// Get port-specific degrees
let (port_in, port_out) = graph.get_port_connection_degree("processor", "data");
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-updates"><a class="header" href="#connection-updates">Connection Updates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update connection metadata
let new_metadata = HashMap::from([
    ("bandwidth".to_string(), json!("high")),
    ("encrypted".to_string(), json!(true))
]);
graph.set_connection_metadata("source", "output", "processor", "input", new_metadata);
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-removal"><a class="header" href="#connection-removal">Connection Removal</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remove specific connection
graph.remove_connection("source", "output", "processor", "input");

// Remove all connections for a node (called automatically when removing node)
graph.remove_node_connections("isolated_node");
<span class="boring">}</span></code></pre></pre>
<h2 id="graph-ports-inportsoutports"><a class="header" href="#graph-ports-inportsoutports">Graph Ports (Inports/Outports)</a></h2>
<p>Graph ports expose internal node ports as external interfaces, making subgraphs reusable.</p>
<h3 id="adding-input-ports"><a class="header" href="#adding-input-ports">Adding Input Ports</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic inport
graph.add_inport("data_input", "processor", "input", PortType::Any, None);

// Inport with metadata
let port_metadata = HashMap::from([
    ("description".to_string(), json!("Main data input stream")),
    ("required".to_string(), json!(true)),
    ("default_value".to_string(), json!(null))
]);
graph.add_inport("config", "processor", "config", PortType::Object("Config".to_string()), Some(port_metadata));
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-output-ports"><a class="header" href="#adding-output-ports">Adding Output Ports</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic outport
graph.add_outport("processed_data", "processor", "output", PortType::Object("ProcessedData".to_string()), None);

// Outport with metadata
let out_metadata = HashMap::from([
    ("description".to_string(), json!("Processed data stream")),
    ("format".to_string(), json!("json"))
]);
graph.add_outport("results", "processor", "result", PortType::Array(Box::new(PortType::Object("Result".to_string()))), Some(out_metadata));
<span class="boring">}</span></code></pre></pre>
<h3 id="port-management"><a class="header" href="#port-management">Port Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update port metadata
let port_updates = HashMap::from([
    ("required".to_string(), json!(false)),
    ("deprecated".to_string(), json!(true))
]);
graph.set_inport_metadata("data_input", port_updates);
graph.set_outport_metadata("results", port_updates);

// Rename ports
graph.rename_inport("old_input", "new_input");
graph.rename_outport("old_output", "new_output");

// Remove ports
graph.remove_inport("unused_input");
graph.remove_outport("unused_output");
<span class="boring">}</span></code></pre></pre>
<h2 id="initial-information-packets-iips"><a class="header" href="#initial-information-packets-iips">Initial Information Packets (IIPs)</a></h2>
<p>IIPs provide static data to nodes at startup.</p>
<h3 id="adding-iips"><a class="header" href="#adding-iips">Adding IIPs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic IIP
graph.add_initial(
    json!("config.yaml"),
    "file_reader",
    "filename",
    None
);

// IIP with metadata
let iip_metadata = HashMap::from([
    ("source".to_string(), json!("configuration")),
    ("priority".to_string(), json!("high"))
]);
graph.add_initial(
    json!({"host": "localhost", "port": 8080}),
    "server",
    "config",
    Some(iip_metadata)
);

// IIP with array index
graph.add_initial_index(
    json!("file1.txt"),
    "multi_reader",
    "files",
    0,
    None
);
<span class="boring">}</span></code></pre></pre>
<h3 id="graph-level-iips"><a class="header" href="#graph-level-iips">Graph-level IIPs</a></h3>
<p>When using graph ports, you can add IIPs at the graph level:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add IIP to graph inport
graph.add_graph_initial(
    json!({"mode": "production"}),
    "config_input",  // Graph inport name
    None
);

// Add indexed IIP to graph inport
graph.add_graph_initial_index(
    json!("primary.db"),
    "database_files",  // Graph inport name
    0,
    None
);
<span class="boring">}</span></code></pre></pre>
<h3 id="removing-iips"><a class="header" href="#removing-iips">Removing IIPs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remove node-level IIP
graph.remove_initial("file_reader", "filename");

// Remove graph-level IIP
graph.remove_graph_initial("config_input");
<span class="boring">}</span></code></pre></pre>
<h2 id="node-groups"><a class="header" href="#node-groups">Node Groups</a></h2>
<p>Groups provide logical organization of related nodes.</p>
<h3 id="creating-groups"><a class="header" href="#creating-groups">Creating Groups</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create basic group
graph.add_group("data_processing", vec!["parser".to_string(), "validator".to_string(), "transformer".to_string()], None);

// Group with metadata
let group_metadata = HashMap::from([
    ("color".to_string(), json!("#2ecc71")),
    ("description".to_string(), json!("Data processing pipeline")),
    ("collapsed".to_string(), json!(false))
]);
graph.add_group("preprocessing", vec!["cleaner".to_string(), "normalizer".to_string()], Some(group_metadata));
<span class="boring">}</span></code></pre></pre>
<h3 id="managing-group-membership"><a class="header" href="#managing-group-membership">Managing Group Membership</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add node to existing group
graph.add_to_group("data_processing", "formatter");

// Remove node from group
graph.remove_from_group("data_processing", "formatter");
<span class="boring">}</span></code></pre></pre>
<h3 id="group-metadata"><a class="header" href="#group-metadata">Group Metadata</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update group metadata
let group_updates = HashMap::from([
    ("collapsed".to_string(), json!(true)),
    ("priority".to_string(), json!("high"))
]);
graph.set_group_metadata("data_processing", group_updates);
<span class="boring">}</span></code></pre></pre>
<h3 id="removing-groups"><a class="header" href="#removing-groups">Removing Groups</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remove entire group (nodes remain, just ungrouped)
graph.remove_group("old_group");
<span class="boring">}</span></code></pre></pre>
<h2 id="graph-properties"><a class="header" href="#graph-properties">Graph Properties</a></h2>
<h3 id="setting-properties"><a class="header" href="#setting-properties">Setting Properties</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set multiple properties
let properties = HashMap::from([
    ("name".to_string(), json!("Updated Workflow")),
    ("version".to_string(), json!("2.0.0")),
    ("description".to_string(), json!("Enhanced data processing")),
    ("tags".to_string(), json!(["data", "processing", "etl"]))
]);
graph.set_properties(properties);
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-properties"><a class="header" href="#getting-properties">Getting Properties</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Properties are accessible via graph.properties field
if let Some(name) = graph.properties.get("name") {
    println!("Graph name: {}", name);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h2>
<h3 id="subscribing-to-events"><a class="header" href="#subscribing-to-events">Subscribing to Events</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::GraphEvents;

// Get event receiver
let event_receiver = graph.event_channel.1.clone();

// Handle events in a loop
std::thread::spawn(move || {
    while let Ok(event) = event_receiver.recv() {
        match event {
            GraphEvents::AddNode(data) =&gt; {
                println!("Node added: {:?}", data);
            }
            GraphEvents::RemoveNode(data) =&gt; {
                println!("Node removed: {:?}", data);
            }
            GraphEvents::AddConnection(data) =&gt; {
                println!("Connection added: {:?}", data);
            }
            GraphEvents::RemoveConnection(data) =&gt; {
                println!("Connection removed: {:?}", data);
            }
            GraphEvents::ChangeNode(data) =&gt; {
                println!("Node changed: {:?}", data);
            }
            // ... handle other events
            _ =&gt; {}
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="event-types-reference"><a class="header" href="#event-types-reference">Event Types Reference</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Triggered When</th><th>Data</th></tr></thead><tbody>
<tr><td><code>AddNode</code></td><td>Node is added</td><td>Node data</td></tr>
<tr><td><code>RemoveNode</code></td><td>Node is removed</td><td>Node data</td></tr>
<tr><td><code>RenameNode</code></td><td>Node is renamed</td><td><code>{old, new}</code></td></tr>
<tr><td><code>ChangeNode</code></td><td>Node metadata changes</td><td><code>{node, old_metadata, new_metadata}</code></td></tr>
<tr><td><code>AddConnection</code></td><td>Connection is added</td><td>Connection data</td></tr>
<tr><td><code>RemoveConnection</code></td><td>Connection is removed</td><td>Connection data</td></tr>
<tr><td><code>ChangeConnection</code></td><td>Connection metadata changes</td><td><code>{connection, old_metadata, new_metadata}</code></td></tr>
<tr><td><code>AddInitial</code></td><td>IIP is added</td><td>IIP data</td></tr>
<tr><td><code>RemoveInitial</code></td><td>IIP is removed</td><td>IIP data</td></tr>
<tr><td><code>AddGroup</code></td><td>Group is created</td><td>Group data</td></tr>
<tr><td><code>RemoveGroup</code></td><td>Group is removed</td><td>Group data</td></tr>
<tr><td><code>RenameGroup</code></td><td>Group is renamed</td><td><code>{old, new}</code></td></tr>
<tr><td><code>ChangeGroup</code></td><td>Group metadata changes</td><td><code>{group, old_metadata, new_metadata}</code></td></tr>
<tr><td><code>AddInport</code></td><td>Inport is added</td><td><code>{id, port}</code></td></tr>
<tr><td><code>RemoveInport</code></td><td>Inport is removed</td><td><code>{id, port}</code></td></tr>
<tr><td><code>RenameInport</code></td><td>Inport is renamed</td><td><code>{old, new}</code></td></tr>
<tr><td><code>ChangeInport</code></td><td>Inport metadata changes</td><td><code>{name, port, old_metadata, new_metadata}</code></td></tr>
<tr><td><code>AddOutport</code></td><td>Outport is added</td><td><code>{id, port}</code></td></tr>
<tr><td><code>RemoveOutport</code></td><td>Outport is removed</td><td><code>{id, port}</code></td></tr>
<tr><td><code>RenameOutport</code></td><td>Outport is renamed</td><td><code>{old, new}</code></td></tr>
<tr><td><code>ChangeOutport</code></td><td>Outport metadata changes</td><td><code>{name, port, old_metadata, new_metadata}</code></td></tr>
<tr><td><code>ChangeProperties</code></td><td>Graph properties change</td><td><code>{new, before}</code></td></tr>
</tbody></table>
</div>
<h2 id="serialization-and-loading"><a class="header" href="#serialization-and-loading">Serialization and Loading</a></h2>
<h3 id="exporting-graphs"><a class="header" href="#exporting-graphs">Exporting Graphs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Export to GraphExport format
let export = graph.export();

// Serialize to JSON
let json_string = serde_json::to_string_pretty(&amp;export)?;
std::fs::write("workflow.json", json_string)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-graphs"><a class="header" href="#loading-graphs">Loading Graphs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Load from JSON
let json_content = std::fs::read_to_string("workflow.json")?;
let export: GraphExport = serde_json::from_str(&amp;json_content)?;

// Create graph from export
let metadata = HashMap::from([
    ("loaded_at".to_string(), json!(chrono::Utc::now().to_rfc3339()))
]);
let loaded_graph = Graph::load(export, Some(metadata));
<span class="boring">}</span></code></pre></pre>
<h2 id="webassembly-api"><a class="header" href="#webassembly-api">WebAssembly API</a></h2>
<p>When using the graph system in a browser via WebAssembly:</p>
<h3 id="javascripttypescript-usage"><a class="header" href="#javascripttypescript-usage">JavaScript/TypeScript Usage</a></h3>
<pre><code class="language-javascript">import { Graph, PortType } from 'reflow-network';

// Create graph
const graph = new Graph("WebWorkflow", false, {
    description: "Browser-based workflow"
});

// Add nodes
graph.addNode("input", "InputNode", { x: 0, y: 0 });
graph.addNode("output", "OutputNode", { x: 200, y: 0 });

// Add connections
graph.addConnection("input", "out", "output", "in", {});

// Subscribe to events
graph.subscribe((event) =&gt; {
    console.log("Graph event:", event);
    // Update UI based on event
    updateUI(event);
});

// Export for persistence
const exported = graph.toJSON();
localStorage.setItem('workflow', JSON.stringify(exported));

// Load saved workflow
const saved = JSON.parse(localStorage.getItem('workflow'));
const restoredGraph = Graph.load(saved, {});
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="common-error-scenarios"><a class="header" href="#common-error-scenarios">Common Error Scenarios</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::GraphError;

// Handle node operations
match graph.add_node("duplicate", "TestNode", None) {
    Ok(_) =&gt; println!("Node added successfully"),
    Err(GraphError::DuplicateNode(id)) =&gt; println!("Node {} already exists", id),
    Err(e) =&gt; println!("Error: {}", e),
}

// Handle traversal errors
match graph.traverse_depth_first("nonexistent", |node| {
    println!("Visiting: {}", node.id);
}) {
    Ok(_) =&gt; println!("Traversal completed"),
    Err(GraphError::NodeNotFound(id)) =&gt; println!("Start node {} not found", id),
    Err(e) =&gt; println!("Traversal error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-types"><a class="header" href="#error-types">Error Types</a></h3>
<ul>
<li><code>NodeNotFound(String)</code> - Referenced node doesn't exist</li>
<li><code>DuplicateNode(String)</code> - Node with same ID already exists</li>
<li><code>InvalidConnection { from: String, to: String }</code> - Connection cannot be created</li>
<li><code>CycleDetected</code> - Operation would create a cycle (if validation enabled)</li>
<li><code>InvalidOperation(String)</code> - Generic operation error</li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h3>
<ol>
<li>
<p><strong>Batch Operations</strong>: Group related changes to minimize events</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of individual operations, batch them
graph.add_node("n1", "Node1", None);
graph.add_node("n2", "Node2", None);
graph.add_connection("n1", "out", "n2", "in", None);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Use Appropriate Data Structures</strong>: Store frequently accessed metadata efficiently</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: structured metadata
let metadata = HashMap::from([
    ("config".to_string(), json!({
        "retries": 3,
        "timeout": 30
    }))
]);

// Avoid: flat key-value for complex data
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Validate Incrementally</strong>: Use targeted validation instead of full graph validation</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check specific aspects instead of full validation
if let Some(cycle) = graph.detect_cycles() {
    // Handle cycle
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h3>
<ol>
<li>
<p><strong>Limit History</strong>: Use bounded history for production systems</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (graph, history) = Graph::with_history_and_limit(50);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Clean Up Events</strong>: Ensure event listeners are properly disposed</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Store receiver handle to drop when done
let receiver = graph.event_channel.1.clone();
// ... use receiver
drop(receiver); // Clean up
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Efficient Metadata</strong>: Avoid storing large objects in metadata</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: reference to external data
let metadata = HashMap::from([
    ("data_ref".to_string(), json!("storage://large-dataset-id"))
]);

// Avoid: embedding large data
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="analysis.html">Graph Analysis</a> - Validation and performance analysis</li>
<li><a href="layout.html">Layout System</a> - Positioning and visualization</li>
<li><a href="advanced.html">Advanced Features</a> - History, subgraphs, and optimization</li>
<li><a href="../../tutorials/building-visual-editor.html">Building Visual Editors</a> - Complete tutorial</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../api/actors/creating-actors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../api/graph/analysis.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../api/actors/creating-actors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../api/graph/analysis.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
