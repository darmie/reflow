<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Event Types - Reflow Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the Reflow workflow automation engine - featuring distributed graph network and multi-graph composition">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Reflow Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/reflow-project/reflow" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/reflow-project/reflow/edit/main/docs/docs/observability/event-types.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="event-types-reference"><a class="header" href="#event-types-reference">Event Types Reference</a></h1>
<p>The Reflow observability framework captures comprehensive trace events that provide deep insights into actor network behavior. This reference covers all available event types, their structure, and usage patterns.</p>
<h2 id="core-event-structure"><a class="header" href="#core-event-structure">Core Event Structure</a></h2>
<p>All trace events share a common structure defined in <code>TraceEvent</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TraceEvent {
    pub event_id: EventId,           // Unique event identifier
    pub timestamp: DateTime&lt;Utc&gt;,    // UTC timestamp
    pub event_type: TraceEventType,  // Event type (see below)
    pub actor_id: String,            // Source actor identifier
    pub data: TraceEventData,        // Event-specific data
    pub causality: CausalityInfo,    // Causality tracking
}
<span class="boring">}</span></code></pre></pre>
<h2 id="actor-lifecycle-events"><a class="header" href="#actor-lifecycle-events">Actor Lifecycle Events</a></h2>
<h3 id="actorcreated"><a class="header" href="#actorcreated">ActorCreated</a></h3>
<p>Triggered when an actor instance is created.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventType::ActorCreated
<span class="boring">}</span></code></pre></pre>
<p><strong>When Generated</strong>:</p>
<ul>
<li>Actor registration in network</li>
<li>Dynamic actor instantiation</li>
<li>Actor factory creation</li>
</ul>
<p><strong>Event Data</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventData {
    port: None,
    message: None,
    state_diff: None,
    error: None,
    performance_metrics: PerformanceMetrics::default(),
    custom_attributes: HashMap::from([
        ("actor_type", json!("DataProcessor")),
        ("config", json!({"timeout": 5000})),
        ("instance_id", json!("proc_001")),
    ]),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(tracing) = global_tracing() {
    tracing.trace_actor_created("data_processor").await?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="actorstarted"><a class="header" href="#actorstarted">ActorStarted</a></h3>
<p>Triggered when an actor begins execution.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventType::ActorStarted
<span class="boring">}</span></code></pre></pre>
<p><strong>When Generated</strong>:</p>
<ul>
<li>Actor process startup</li>
<li>Actor behavior initialization</li>
<li>Resource allocation completion</li>
</ul>
<p><strong>Event Data</strong>: Includes initialization metrics and startup configuration.</p>
<h3 id="actorcompleted"><a class="header" href="#actorcompleted">ActorCompleted</a></h3>
<p>Triggered when an actor successfully completes execution.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventType::ActorCompleted
<span class="boring">}</span></code></pre></pre>
<p><strong>When Generated</strong>:</p>
<ul>
<li>Successful actor termination</li>
<li>Graceful shutdown completion</li>
<li>Task completion</li>
</ul>
<p><strong>Event Data</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventData {
    performance_metrics: PerformanceMetrics {
        execution_time_ns: 150_000_000,  // 150ms
        memory_usage_bytes: 1024,
        cpu_usage_percent: 15.5,
        queue_depth: 0,
        throughput_msgs_per_sec: 100.0,
    },
    custom_attributes: HashMap::from([
        ("exit_code", json!(0)),
        ("processed_messages", json!(42)),
    ]),
    ..Default::default()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="actorfailed"><a class="header" href="#actorfailed">ActorFailed</a></h3>
<p>Triggered when an actor encounters an error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventType::ActorFailed
<span class="boring">}</span></code></pre></pre>
<p><strong>When Generated</strong>:</p>
<ul>
<li>Unhandled exceptions</li>
<li>Resource exhaustion</li>
<li>Configuration errors</li>
<li>Network failures</li>
</ul>
<p><strong>Event Data</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventData {
    error: Some("Connection timeout: Failed to connect to database".to_string()),
    performance_metrics: PerformanceMetrics {
        execution_time_ns: 5_000_000_000, // 5 seconds before timeout
        memory_usage_bytes: 2048,
        cpu_usage_percent: 95.0,
        queue_depth: 10,
        throughput_msgs_per_sec: 0.0,
    },
    custom_attributes: HashMap::from([
        ("error_code", json!("TIMEOUT")),
        ("retry_count", json!(3)),
        ("last_successful_operation", json!("database_query")),
    ]),
    ..Default::default()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="communication-events"><a class="header" href="#communication-events">Communication Events</a></h2>
<h3 id="messagesent"><a class="header" href="#messagesent">MessageSent</a></h3>
<p>Triggered when an actor sends a message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventType::MessageSent
<span class="boring">}</span></code></pre></pre>
<p><strong>When Generated</strong>:</p>
<ul>
<li>Message transmission to ports</li>
<li>Inter-actor communication</li>
<li>Network message dispatch</li>
</ul>
<p><strong>Event Data</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventData {
    port: Some("output".to_string()),
    message: Some(MessageSnapshot {
        message_type: "ProcessedData".to_string(),
        size_bytes: 1024,
        checksum: "sha256:abc123...".to_string(),
        serialized_data: vec![], // Optional: actual message data
    }),
    performance_metrics: PerformanceMetrics {
        execution_time_ns: 1_000_000, // 1ms serialization time
        ..Default::default()
    },
    ..Default::default()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="messagereceived"><a class="header" href="#messagereceived">MessageReceived</a></h3>
<p>Triggered when an actor receives a message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventType::MessageReceived
<span class="boring">}</span></code></pre></pre>
<p><strong>When Generated</strong>:</p>
<ul>
<li>Message reception on ports</li>
<li>Queue processing</li>
<li>Message deserialization</li>
</ul>
<p><strong>Event Data</strong>: Similar to <code>MessageSent</code> but from receiver perspective.</p>
<h3 id="dataflow-new"><a class="header" href="#dataflow-new">DataFlow (NEW)</a></h3>
<p>Automatically triggered when data flows between connected actors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventType::DataFlow {
    to_actor: String,
    to_port: String,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>When Generated</strong>:</p>
<ul>
<li>Connector-level message transmission</li>
<li>Data pipeline operations</li>
<li>Cross-actor data transfer</li>
</ul>
<p><strong>Event Data</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventData {
    port: Some("output".to_string()), // Source port
    message: Some(MessageSnapshot {
        message_type: "SensorReading".to_string(),
        size_bytes: 256,
        checksum: "sha256:def456...".to_string(),
        serialized_data: vec![],
    }),
    performance_metrics: PerformanceMetrics {
        execution_time_ns: 500_000, // 0.5ms transfer time
        queue_depth: 5, // Current queue depth at destination
        throughput_msgs_per_sec: 1000.0,
        ..Default::default()
    },
    custom_attributes: HashMap::from([
        ("source_actor", json!("sensor_reader")),
        ("source_port", json!("output")),
        ("destination_actor", json!("data_validator")),
        ("destination_port", json!("input")),
        ("transfer_protocol", json!("memory")),
    ]),
    ..Default::default()
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Usage</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatic - no manual code needed
// Generated when messages flow through connectors

// Manual usage for custom connectors:
tracing.trace_data_flow(
    "source_actor", "output_port",
    "dest_actor", "input_port", 
    "CustomMessage", 512
).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="state-management-events"><a class="header" href="#state-management-events">State Management Events</a></h2>
<h3 id="statechanged"><a class="header" href="#statechanged">StateChanged</a></h3>
<p>Triggered when an actor's state is modified.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventType::StateChanged
<span class="boring">}</span></code></pre></pre>
<p><strong>When Generated</strong>:</p>
<ul>
<li>State updates</li>
<li>Configuration changes</li>
<li>Memory state modifications</li>
</ul>
<p><strong>Event Data</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventData {
    state_diff: Some(StateDiff {
        before: Some(previous_state_bytes),
        after: current_state_bytes,
        diff_type: StateDiffType::Incremental,
    }),
    performance_metrics: PerformanceMetrics {
        execution_time_ns: 2_000_000, // 2ms state update time
        memory_usage_bytes: 4096, // Memory used by state
        ..Default::default()
    },
    custom_attributes: HashMap::from([
        ("state_version", json!(42)),
        ("state_size_bytes", json!(4096)),
        ("changed_fields", json!(["counter", "last_update"])),
    ]),
    ..Default::default()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="network-events"><a class="header" href="#network-events">Network Events</a></h2>
<h3 id="portconnected"><a class="header" href="#portconnected">PortConnected</a></h3>
<p>Triggered when actor ports are connected.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventType::PortConnected
<span class="boring">}</span></code></pre></pre>
<p><strong>Event Data</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventData {
    port: Some("output".to_string()),
    custom_attributes: HashMap::from([
        ("connected_to_actor", json!("downstream_processor")),
        ("connected_to_port", json!("input")),
        ("connection_type", json!("memory_channel")),
        ("buffer_size", json!(1000)),
    ]),
    ..Default::default()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="portdisconnected"><a class="header" href="#portdisconnected">PortDisconnected</a></h3>
<p>Triggered when actor ports are disconnected.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventType::PortDisconnected
<span class="boring">}</span></code></pre></pre>
<p><strong>Event Data</strong>: Similar to <code>PortConnected</code> but for disconnection events.</p>
<h3 id="networkevent"><a class="header" href="#networkevent">NetworkEvent</a></h3>
<p>Triggered for network-level operations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventType::NetworkEvent
<span class="boring">}</span></code></pre></pre>
<p><strong>When Generated</strong>:</p>
<ul>
<li>Network startup/shutdown</li>
<li>Actor registration/deregistration</li>
<li>Distributed network operations</li>
<li>Load balancing events</li>
</ul>
<p><strong>Event Data</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TraceEventData {
    custom_attributes: HashMap::from([
        ("event_subtype", json!("actor_registered")),
        ("network_id", json!("production_cluster")),
        ("node_count", json!(5)),
        ("total_actors", json!(150)),
    ]),
    ..Default::default()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-metrics"><a class="header" href="#performance-metrics">Performance Metrics</a></h2>
<p>All events include performance metrics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PerformanceMetrics {
    pub execution_time_ns: u64,      // Nanoseconds
    pub memory_usage_bytes: usize,   // Bytes
    pub cpu_usage_percent: f32,      // 0.0 - 100.0
    pub queue_depth: usize,          // Messages in queue
    pub throughput_msgs_per_sec: f64, // Messages per second
}
<span class="boring">}</span></code></pre></pre>
<h3 id="interpreting-metrics"><a class="header" href="#interpreting-metrics">Interpreting Metrics</a></h3>
<ul>
<li><strong>execution_time_ns</strong>: Time spent on the operation</li>
<li><strong>memory_usage_bytes</strong>: Memory footprint at time of event</li>
<li><strong>cpu_usage_percent</strong>: CPU utilization during operation</li>
<li><strong>queue_depth</strong>: Number of pending messages</li>
<li><strong>throughput_msgs_per_sec</strong>: Recent message processing rate</li>
</ul>
<h2 id="causality-information"><a class="header" href="#causality-information">Causality Information</a></h2>
<p>Events maintain causality chains for dependency tracking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CausalityInfo {
    pub parent_event_id: Option&lt;EventId&gt;,    // Direct parent event
    pub root_cause_event_id: EventId,        // Root cause in chain
    pub dependency_chain: Vec&lt;EventId&gt;,      // Full dependency chain
    pub span_id: String,                     // Distributed tracing span
}
<span class="boring">}</span></code></pre></pre>
<h3 id="building-causality-chains"><a class="header" href="#building-causality-chains">Building Causality Chains</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Events can reference parent events
let parent_event_id = previous_event.event_id;

let child_event = TraceEvent {
    causality: CausalityInfo {
        parent_event_id: Some(parent_event_id),
        root_cause_event_id: original_trigger_event_id,
        dependency_chain: vec![original_trigger_event_id, parent_event_id],
        span_id: distributed_span_id,
    },
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-events"><a class="header" href="#custom-events">Custom Events</a></h2>
<p>Create custom event types for domain-specific tracing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Custom event type
TraceEventType::Custom("deployment_started".to_string())

// Create custom event
let custom_event = TraceEvent {
    event_type: TraceEventType::Custom("model_training_completed".to_string()),
    actor_id: "ml_trainer".to_string(),
    data: TraceEventData {
        custom_attributes: HashMap::from([
            ("model_type", json!("neural_network")),
            ("training_epochs", json!(100)),
            ("accuracy", json!(0.95)),
            ("model_size_mb", json!(25.4)),
            ("training_time_hours", json!(3.5)),
        ]),
        performance_metrics: PerformanceMetrics {
            execution_time_ns: 12_600_000_000_000, // 3.5 hours in ns
            memory_usage_bytes: 1_073_741_824, // 1GB
            cpu_usage_percent: 85.0,
            ..Default::default()
        },
        ..Default::default()
    },
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="event-filtering"><a class="header" href="#event-filtering">Event Filtering</a></h2>
<p>Filter events by type for focused analysis:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Subscribe to specific event types
let filters = SubscriptionFilters {
    flow_ids: Some(vec![FlowId::new("production_pipeline")]),
    actor_ids: Some(vec!["data_processor".to_string()]),
    event_types: Some(vec![
        TraceEventType::ActorCreated,
        TraceEventType::ActorFailed,
        TraceEventType::DataFlow { 
            to_actor: "analytics_engine".to_string(),
            to_port: "input".to_string(),
        },
    ]),
    status_filter: Some(vec![ExecutionStatus::Failed]),
};
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="event-granularity"><a class="header" href="#event-granularity">Event Granularity</a></h3>
<ul>
<li><strong>High-Frequency Operations</strong>: Use sampling for message passing in high-throughput scenarios</li>
<li><strong>Critical Operations</strong>: Always trace actor lifecycle events and failures</li>
<li><strong>Debug Information</strong>: Use custom attributes for debugging context</li>
</ul>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Efficient event creation
let event = TraceEvent::data_flow(
    source_actor, source_port,
    dest_actor, dest_port,
    message_type, message_size
);

// Batch similar events
if batch.len() &gt;= batch_size {
    tracing.record_batch(batch).await?;
    batch.clear();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="security--privacy"><a class="header" href="#security--privacy">Security &amp; Privacy</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Filter sensitive data
let safe_attributes = attributes.into_iter()
    .filter(|(key, _)| !SENSITIVE_FIELDS.contains(key))
    .collect();

// Hash sensitive identifiers
let user_hash = format!("user_{}", hash(&amp;user_id));
attributes.insert("user_hash", json!(user_hash));
<span class="boring">}</span></code></pre></pre>
<h2 id="query-patterns"><a class="header" href="#query-patterns">Query Patterns</a></h2>
<h3 id="common-queries"><a class="header" href="#common-queries">Common Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find all failed actors in last hour
let query = TraceQuery {
    time_range: Some((Utc::now() - Duration::hours(1), Utc::now())),
    status: Some(ExecutionStatus::Failed),
    ..Default::default()
};

// Trace data flow for specific message type
let query = TraceQuery {
    actor_filter: Some(".*processor.*".to_string()), // Regex
    event_types: Some(vec![TraceEventType::DataFlow { 
        to_actor: "*".to_string(), 
        to_port: "*".to_string() 
    }]),
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-analysis"><a class="header" href="#performance-analysis">Performance Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find slowest operations
SELECT actor_id, AVG(execution_time_ns) as avg_time_ns
FROM trace_events 
WHERE event_type = 'ActorCompleted'
  AND timestamp &gt; NOW() - INTERVAL '1 hour'
GROUP BY actor_id
ORDER BY avg_time_ns DESC;
<span class="boring">}</span></code></pre></pre>
<p>This comprehensive event reference provides the foundation for effective observability in Reflow actor networks. Each event type serves specific monitoring and debugging use cases, enabling deep insights into system behavior and performance.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../observability/architecture.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../observability/data-flow-tracing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../observability/architecture.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../observability/data-flow-tracing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
