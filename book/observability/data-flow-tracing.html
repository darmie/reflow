<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Flow Tracing - Reflow Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the Reflow workflow automation engine - featuring distributed graph network and multi-graph composition">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Reflow Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/reflow-project/reflow" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/reflow-project/reflow/edit/main/docs/docs/observability/data-flow-tracing.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="data-flow-tracing"><a class="header" href="#data-flow-tracing">Data Flow Tracing</a></h1>
<p>Data Flow Tracing is a core component of Reflow's observability framework, providing automatic and comprehensive tracking of data movement between actors in your network. This feature gives you unprecedented visibility into how information flows through your system.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Traditional actor monitoring focuses on individual actor behavior - creation, completion, and failures. Data Flow Tracing extends this by capturing the <strong>connections</strong> between actors, providing insights into:</p>
<ul>
<li><strong>Message Routing</strong>: How messages travel through your actor network</li>
<li><strong>Data Lineage</strong>: Complete paths of data transformation</li>
<li><strong>Performance Bottlenecks</strong>: Where data flow slows down or gets congested</li>
<li><strong>System Dependencies</strong>: Which actors depend on which data sources</li>
</ul>
<h2 id="how-data-flow-tracing-works"><a class="header" href="#how-data-flow-tracing-works">How Data Flow Tracing Works</a></h2>
<h3 id="automatic-capture"><a class="header" href="#automatic-capture">Automatic Capture</a></h3>
<p>Data Flow Tracing operates at the <strong>connector level</strong>, intercepting messages as they flow between actors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatic tracing in connector implementation
impl Connector {
    pub async fn send_message(&amp;self, message: Message) -&gt; Result&lt;()&gt; {
        // Send the actual message
        self.channel.send(message.clone()).await?;
        
        // Automatically record data flow event
        if let Some(tracing) = global_tracing() {
            tracing.trace_data_flow(
                &amp;self.from_actor, &amp;self.from_port,
                &amp;self.to_actor, &amp;self.to_port,
                message.type_name(), message.size_bytes()
            ).await?;
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach provides several advantages:</p>
<ul>
<li><strong>Zero Configuration</strong>: Works immediately with existing actor networks</li>
<li><strong>Complete Coverage</strong>: Captures all message flows without missing any</li>
<li><strong>Accurate Timing</strong>: Records actual transmission times</li>
<li><strong>Minimal Overhead</strong>: Efficient implementation with batching</li>
</ul>
<h3 id="event-structure"><a class="header" href="#event-structure">Event Structure</a></h3>
<p>Data Flow events contain rich metadata about the message transfer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DataFlowEvent {
    // Standard event fields
    event_id: EventId,
    timestamp: DateTime&lt;Utc&gt;,
    event_type: TraceEventType::DataFlow {
        to_actor: String,    // Destination actor
        to_port: String,     // Destination port
    },
    actor_id: String,        // Source actor (from_actor)
    
    // Data flow specific information
    data: TraceEventData {
        port: Some("output".to_string()),  // Source port
        message: Some(MessageSnapshot {
            message_type: "SensorReading".to_string(),
            size_bytes: 256,
            checksum: "sha256:abc123...",
            serialized_data: vec![], // Optional data capture
        }),
        performance_metrics: PerformanceMetrics {
            execution_time_ns: 1_500_000,  // 1.5ms transfer time
            queue_depth: 3,                // Destination queue depth
            throughput_msgs_per_sec: 1000.0,
            memory_usage_bytes: 512,       // Memory for message processing
            cpu_usage_percent: 2.5,
        },
        custom_attributes: HashMap::from([
            ("source_actor", json!("sensor_reader")),
            ("source_port", json!("data")),
            ("destination_actor", json!("data_processor")),
            ("destination_port", json!("input")),
            ("message_id", json!("msg_12345")),
            ("protocol", json!("memory_channel")),
            ("compression", json!("none")),
        ]),
        ..Default::default()
    },
}
<span class="boring">}</span></code></pre></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="1-data-lineage-tracking"><a class="header" href="#1-data-lineage-tracking">1. Data Lineage Tracking</a></h3>
<p>Track how data flows and transforms through your entire pipeline:</p>
<pre><code class="language-mermaid">graph LR
    A[Sensor Reader] --&gt;|SensorReading| B[Data Validator]
    B --&gt;|ValidatedReading| C[Data Transformer]
    C --&gt;|ProcessedData| D[Analytics Engine]
    D --&gt;|Insights| E[Dashboard]
    
    style A fill:#e1f5fe
    style E fill:#f3e5f5
</code></pre>
<p>Query for complete data lineage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find all data flow for a specific message
let query = TraceQuery {
    event_types: Some(vec![TraceEventType::DataFlow { 
        to_actor: "*".to_string(), 
        to_port: "*".to_string() 
    }]),
    custom_filter: Some("message_id = 'msg_12345'"),
    ..Default::default()
};

let lineage = tracing_client.query_traces(query).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-performance-analysis"><a class="header" href="#2-performance-analysis">2. Performance Analysis</a></h3>
<p>Identify bottlenecks in your data processing pipeline:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Query for slow data transfers
let slow_transfers = TraceQuery {
    event_types: Some(vec![TraceEventType::DataFlow { 
        to_actor: "*".to_string(), 
        to_port: "*".to_string() 
    }]),
    performance_filter: Some("execution_time_ns &gt; 10000000"), // &gt; 10ms
    time_range: Some((Utc::now() - Duration::hours(1), Utc::now())),
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="3-system-dependency-mapping"><a class="header" href="#3-system-dependency-mapping">3. System Dependency Mapping</a></h3>
<p>Understand which actors depend on which data sources:</p>
<pre><code class="language-sql">-- Find most active data flows
SELECT 
    source_actor,
    destination_actor,
    COUNT(*) as message_count,
    AVG(execution_time_ns) as avg_transfer_time,
    SUM(size_bytes) as total_bytes
FROM data_flow_events 
WHERE timestamp &gt; NOW() - INTERVAL '1 hour'
GROUP BY source_actor, destination_actor
ORDER BY message_count DESC;
</code></pre>
<h3 id="4-real-time-monitoring"><a class="header" href="#4-real-time-monitoring">4. Real-time Monitoring</a></h3>
<p>Monitor data flow in real-time for operational awareness:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Subscribe to data flow events for specific actors
let filters = SubscriptionFilters {
    actor_ids: Some(vec!["critical_processor".to_string()]),
    event_types: Some(vec![TraceEventType::DataFlow { 
        to_actor: "*".to_string(), 
        to_port: "*".to_string() 
    }]),
    ..Default::default()
};

tracing_client.subscribe(filters).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="enabling-data-flow-tracing"><a class="header" href="#enabling-data-flow-tracing">Enabling Data Flow Tracing</a></h3>
<p>Data Flow Tracing is enabled automatically when you enable the observability framework:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tracing_config = TracingConfig {
    server_url: "ws://localhost:8080".to_string(),
    enabled: true,                    // Enables all tracing including data flow
    batch_size: 50,                  // Batch size for data flow events
    batch_timeout: Duration::from_millis(1000),
    enable_compression: true,         // Recommended for data flow events
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="selective-tracing"><a class="header" href="#selective-tracing">Selective Tracing</a></h3>
<p>For high-throughput systems, you might want to selectively trace certain data flows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Custom connector with selective tracing
impl SelectiveConnector {
    pub async fn send_message(&amp;self, message: Message) -&gt; Result&lt;()&gt; {
        self.channel.send(message.clone()).await?;
        
        // Only trace certain message types or conditions
        if should_trace_message(&amp;message) {
            if let Some(tracing) = global_tracing() {
                tracing.trace_data_flow(
                    &amp;self.from_actor, &amp;self.from_port,
                    &amp;self.to_actor, &amp;self.to_port,
                    message.type_name(), message.size_bytes()
                ).await?;
            }
        }
        
        Ok(())
    }
}

fn should_trace_message(message: &amp;Message) -&gt; bool {
    // Trace based on message type, size, or other criteria
    match message.type_name() {
        "CriticalAlert" =&gt; true,        // Always trace alerts
        "DebugInfo" =&gt; false,           // Never trace debug info
        "DataUpdate" if message.size_bytes() &gt; 1024 =&gt; true, // Large updates only
        _ =&gt; rand::random::&lt;f64&gt;() &lt; 0.1, // Sample 10% of other messages
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="sampling-configuration"><a class="header" href="#sampling-configuration">Sampling Configuration</a></h3>
<p>For extremely high-throughput scenarios, implement sampling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DataFlowSampler {
    sample_rate: f64,      // 0.0 to 1.0
    always_trace: Vec&lt;String&gt;, // Actor names to always trace
    never_trace: Vec&lt;String&gt;,  // Actor names to never trace
}

impl DataFlowSampler {
    pub fn should_trace(&amp;self, from_actor: &amp;str, to_actor: &amp;str) -&gt; bool {
        if self.never_trace.contains(&amp;from_actor.to_string()) ||
           self.never_trace.contains(&amp;to_actor.to_string()) {
            return false;
        }
        
        if self.always_trace.contains(&amp;from_actor.to_string()) ||
           self.always_trace.contains(&amp;to_actor.to_string()) {
            return true;
        }
        
        rand::random::&lt;f64&gt;() &lt; self.sample_rate
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="message-content-capture"><a class="header" href="#message-content-capture">Message Content Capture</a></h3>
<p>For debugging purposes, you can optionally capture message content:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let event = TraceEvent::data_flow_with_content(
    from_actor, from_port,
    to_actor, to_port,
    message_type, size_bytes,
    Some(message.serialize()?) // Optional content capture
);
<span class="boring">}</span></code></pre></pre>
<p>⚠️ <strong>Security Warning</strong>: Be careful when capturing message content in production. Ensure no sensitive data is included.</p>
<h3 id="custom-metadata"><a class="header" href="#custom-metadata">Custom Metadata</a></h3>
<p>Add custom metadata to data flow events:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enhanced data flow tracing with custom metadata
pub async fn trace_enhanced_data_flow(
    tracing: &amp;TracingIntegration,
    from_actor: &amp;str, from_port: &amp;str,
    to_actor: &amp;str, to_port: &amp;str,
    message: &amp;Message,
    custom_metadata: HashMap&lt;String, serde_json::Value&gt;
) -&gt; Result&lt;()&gt; {
    let mut event = TraceEvent::data_flow(
        from_actor.to_string(), from_port.to_string(),
        to_actor.to_string(), to_port.to_string(),
        message.type_name(), message.size_bytes()
    );
    
    // Add custom metadata
    event.data.custom_attributes.extend(custom_metadata);
    
    // Add message-specific metadata
    event.data.custom_attributes.insert(
        "message_priority".to_string(), 
        json!(message.priority())
    );
    event.data.custom_attributes.insert(
        "message_correlation_id".to_string(), 
        json!(message.correlation_id())
    );
    
    tracing.record_event(event).await
}
<span class="boring">}</span></code></pre></pre>
<h3 id="causality-tracking"><a class="header" href="#causality-tracking">Causality Tracking</a></h3>
<p>Link data flow events to their triggering events:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn trace_causally_linked_data_flow(
    tracing: &amp;TracingIntegration,
    triggering_event_id: EventId,
    from_actor: &amp;str, from_port: &amp;str,
    to_actor: &amp;str, to_port: &amp;str,
    message: &amp;Message
) -&gt; Result&lt;()&gt; {
    let mut event = TraceEvent::data_flow(
        from_actor.to_string(), from_port.to_string(),
        to_actor.to_string(), to_port.to_string(),
        message.type_name(), message.size_bytes()
    );
    
    // Link to triggering event
    event.causality.parent_event_id = Some(triggering_event_id);
    event.causality.dependency_chain.push(triggering_event_id);
    
    tracing.record_event(event).await
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="overhead-analysis"><a class="header" href="#overhead-analysis">Overhead Analysis</a></h3>
<p>Data Flow Tracing introduces minimal overhead:</p>
<ul>
<li><strong>Memory</strong>: ~200 bytes per event</li>
<li><strong>CPU</strong>: ~0.1ms per event (including serialization)</li>
<li><strong>Network</strong>: Batched transmission reduces network calls</li>
<li><strong>Storage</strong>: ~1KB per event when stored</li>
</ul>
<h3 id="optimization-strategies"><a class="header" href="#optimization-strategies">Optimization Strategies</a></h3>
<ol>
<li><strong>Batching</strong>: Use larger batch sizes for high-throughput scenarios</li>
<li><strong>Compression</strong>: Enable compression for network transmission</li>
<li><strong>Sampling</strong>: Sample events rather than capturing every one</li>
<li><strong>Filtering</strong>: Use selective tracing based on criticality</li>
<li><strong>Async Processing</strong>: All tracing operations are non-blocking</li>
</ol>
<h3 id="monitoring-performance-impact"><a class="header" href="#monitoring-performance-impact">Monitoring Performance Impact</a></h3>
<p>Monitor the tracing system's own performance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Monitor tracing overhead
let tracing_metrics = global_tracing()
    .unwrap()
    .get_performance_metrics()
    .await?;

println!("Events per second: {}", tracing_metrics.events_per_second);
println!("Average latency: {}ms", tracing_metrics.avg_latency_ms);
println!("Memory usage: {}MB", tracing_metrics.memory_usage_mb);
<span class="boring">}</span></code></pre></pre>
<h2 id="visualization-and-analysis"><a class="header" href="#visualization-and-analysis">Visualization and Analysis</a></h2>
<h3 id="data-flow-diagrams"><a class="header" href="#data-flow-diagrams">Data Flow Diagrams</a></h3>
<p>Generate visual representations of your data flow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Generate data flow graph for the last hour
let flow_data = tracing_client.query_data_flows(
    TraceQuery {
        time_range: Some((Utc::now() - Duration::hours(1), Utc::now())),
        ..Default::default()
    }
).await?;

let graph = DataFlowGraph::from_events(&amp;flow_data);
graph.render_to_file("data_flow_diagram.svg")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="real-time-dashboard"><a class="header" href="#real-time-dashboard">Real-time Dashboard</a></h3>
<p>Build real-time monitoring dashboards:</p>
<pre><code class="language-javascript">// WebSocket connection for real-time data flow monitoring
const ws = new WebSocket('ws://tracing-server:8080');

ws.onmessage = (event) =&gt; {
    const traceEvent = JSON.parse(event.data);
    if (traceEvent.event_type.DataFlow) {
        updateDataFlowVisualization(traceEvent);
    }
};
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>No Data Flow Events Appearing</strong>:</p>
<ul>
<li>Verify tracing is enabled: <code>enabled: true</code></li>
<li>Check that actors are connected via standard connectors</li>
<li>Ensure global tracing is initialized before network operations</li>
</ul>
<p><strong>Too Many Events</strong>:</p>
<ul>
<li>Implement sampling: reduce <code>sample_rate</code></li>
<li>Use selective tracing for specific actors only</li>
<li>Increase <code>batch_size</code> to reduce network overhead</li>
</ul>
<p><strong>Performance Impact</strong>:</p>
<ul>
<li>Enable compression: <code>enable_compression: true</code></li>
<li>Use PostgreSQL backend for better concurrent performance</li>
<li>Consider async event processing</li>
</ul>
<h3 id="debugging-data-flow-issues"><a class="header" href="#debugging-data-flow-issues">Debugging Data Flow Issues</a></h3>
<p>Use data flow tracing to debug connectivity and performance issues:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debug missing data flows
let missing_flows = TraceQuery {
    actor_filter: Some("source_actor".to_string()),
    event_types: Some(vec![TraceEventType::MessageSent]),
    time_range: Some((start_time, end_time)),
    ..Default::default()
};

let sent_messages = tracing_client.query_traces(missing_flows).await?;

// Check if corresponding DataFlow events exist
for sent_event in sent_messages {
    let corresponding_flow = find_data_flow_for_message(&amp;sent_event).await?;
    if corresponding_flow.is_none() {
        println!("Missing data flow for message: {:?}", sent_event);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Start Simple</strong>: Begin with default settings and tune based on your needs</li>
<li><strong>Monitor Overhead</strong>: Keep an eye on the performance impact of tracing</li>
<li><strong>Use Sampling</strong>: For high-throughput systems, sample rather than trace everything</li>
<li><strong>Secure Sensitive Data</strong>: Never trace sensitive message content</li>
<li><strong>Regular Cleanup</strong>: Set up automatic cleanup of old trace data</li>
<li><strong>Correlate Events</strong>: Use causality tracking to link related events</li>
<li><strong>Custom Metadata</strong>: Add domain-specific metadata for better insights</li>
</ol>
<p>Data Flow Tracing provides unprecedented visibility into your actor network's communication patterns. Use it to understand, debug, and optimize your distributed systems with confidence.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../observability/event-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../observability/configuration.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../observability/event-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../observability/configuration.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
