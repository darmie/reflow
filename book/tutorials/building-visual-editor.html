<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building a Visual Editor - Reflow Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the Reflow workflow automation platform">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Reflow Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="building-a-visual-graph-editor"><a class="header" href="#building-a-visual-graph-editor">Building a Visual Graph Editor</a></h1>
<p>Complete tutorial for creating a visual graph editor using Reflow's WebAssembly APIs.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This tutorial walks through building a complete visual graph editor that allows users to:</p>
<ul>
<li>Create and edit graphs visually</li>
<li>Add nodes by dragging from a component palette</li>
<li>Connect nodes with visual links</li>
<li>Configure node properties through forms</li>
<li>Execute workflows and see real-time results</li>
<li>Save and load graph files</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Basic HTML, CSS, and JavaScript knowledge</li>
<li>Understanding of Reflow's graph concepts</li>
<li>Node.js and npm installed</li>
</ul>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<h3 id="1-initialize-project"><a class="header" href="#1-initialize-project">1. Initialize Project</a></h3>
<pre><code class="language-bash">mkdir reflow-visual-editor
cd reflow-visual-editor
npm init -y
</code></pre>
<h3 id="2-install-dependencies"><a class="header" href="#2-install-dependencies">2. Install Dependencies</a></h3>
<pre><code class="language-bash"># Core dependencies
npm install reflow-network-wasm

# Development dependencies
npm install --save-dev webpack webpack-cli webpack-dev-server
npm install --save-dev html-webpack-plugin css-loader style-loader
npm install --save-dev @babel/core @babel/preset-env babel-loader
</code></pre>
<h3 id="3-project-structure"><a class="header" href="#3-project-structure">3. Project Structure</a></h3>
<pre><code>reflow-visual-editor/
├── src/
│   ├── index.html
│   ├── index.js
│   ├── style.css
│   ├── components/
│   │   ├── Graph.js
│   │   ├── Node.js
│   │   ├── Connection.js
│   │   ├── Palette.js
│   │   └── PropertyPanel.js
│   ├── utils/
│   │   ├── drag-drop.js
│   │   ├── events.js
│   │   └── serialization.js
│   └── workers/
│       └── execution-worker.js
├── webpack.config.js
└── package.json
</code></pre>
<h2 id="core-implementation"><a class="header" href="#core-implementation">Core Implementation</a></h2>
<h3 id="1-basic-html-structure"><a class="header" href="#1-basic-html-structure">1. Basic HTML Structure</a></h3>
<pre><code class="language-html">&lt;!-- src/index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Reflow Visual Editor&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;header class="toolbar"&gt;
            &lt;div class="toolbar-group"&gt;
                &lt;button id="new-graph"&gt;New&lt;/button&gt;
                &lt;button id="open-graph"&gt;Open&lt;/button&gt;
                &lt;button id="save-graph"&gt;Save&lt;/button&gt;
            &lt;/div&gt;
            &lt;div class="toolbar-group"&gt;
                &lt;button id="run-graph"&gt;Run&lt;/button&gt;
                &lt;button id="stop-graph"&gt;Stop&lt;/button&gt;
                &lt;button id="validate-graph"&gt;Validate&lt;/button&gt;
            &lt;/div&gt;
            &lt;div class="toolbar-group"&gt;
                &lt;button id="auto-layout"&gt;Auto Layout&lt;/button&gt;
                &lt;button id="zoom-fit"&gt;Zoom to Fit&lt;/button&gt;
            &lt;/div&gt;
        &lt;/header&gt;
        
        &lt;div class="editor-container"&gt;
            &lt;div class="sidebar"&gt;
                &lt;div class="component-palette" id="palette"&gt;
                    &lt;h3&gt;Components&lt;/h3&gt;
                    &lt;div class="palette-category" data-category="data"&gt;
                        &lt;h4&gt;Data Operations&lt;/h4&gt;
                        &lt;div class="palette-items"&gt;
                            &lt;!-- Component items will be populated by JavaScript --&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="palette-category" data-category="flow"&gt;
                        &lt;h4&gt;Flow Control&lt;/h4&gt;
                        &lt;div class="palette-items"&gt;
                            &lt;!-- Component items will be populated by JavaScript --&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="palette-category" data-category="io"&gt;
                        &lt;h4&gt;Input/Output&lt;/h4&gt;
                        &lt;div class="palette-items"&gt;
                            &lt;!-- Component items will be populated by JavaScript --&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class="graph-canvas-container"&gt;
                &lt;svg id="graph-canvas" class="graph-canvas"&gt;
                    &lt;defs&gt;
                        &lt;marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                refX="10" refY="3.5" orient="auto"&gt;
                            &lt;polygon points="0 0, 10 3.5, 0 7" fill="#666" /&gt;
                        &lt;/marker&gt;
                    &lt;/defs&gt;
                    &lt;g id="connections-layer"&gt;&lt;/g&gt;
                    &lt;g id="nodes-layer"&gt;&lt;/g&gt;
                &lt;/svg&gt;
                
                &lt;div class="canvas-overlay"&gt;
                    &lt;div class="zoom-controls"&gt;
                        &lt;button id="zoom-in"&gt;+&lt;/button&gt;
                        &lt;button id="zoom-out"&gt;-&lt;/button&gt;
                        &lt;span id="zoom-level"&gt;100%&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class="properties-panel" id="properties-panel"&gt;
                &lt;h3&gt;Properties&lt;/h3&gt;
                &lt;div id="property-form"&gt;
                    &lt;p&gt;Select a node to edit properties&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="status-bar"&gt;
            &lt;span id="status-text"&gt;Ready&lt;/span&gt;
            &lt;div class="status-indicators"&gt;
                &lt;span id="node-count"&gt;0 nodes&lt;/span&gt;
                &lt;span id="connection-count"&gt;0 connections&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="2-main-application-class"><a class="header" href="#2-main-application-class">2. Main Application Class</a></h3>
<pre><code class="language-javascript">// src/index.js
import { Graph } from 'reflow-network-wasm';
import GraphEditor from './components/Graph.js';
import ComponentPalette from './components/Palette.js';
import PropertyPanel from './components/PropertyPanel.js';
import './style.css';

class VisualEditor {
    constructor() {
        this.graph = new Graph("VisualWorkflow", true, {});
        this.graphEditor = new GraphEditor(this.graph, '#graph-canvas');
        this.palette = new ComponentPalette('#palette');
        this.propertyPanel = new PropertyPanel('#properties-panel');
        
        this.selectedNode = null;
        this.isExecuting = false;
        
        this.initializeEventListeners();
        this.initializeComponents();
    }
    
    initializeEventListeners() {
        // Toolbar events
        document.getElementById('new-graph').addEventListener('click', () =&gt; this.newGraph());
        document.getElementById('open-graph').addEventListener('click', () =&gt; this.openGraph());
        document.getElementById('save-graph').addEventListener('click', () =&gt; this.saveGraph());
        document.getElementById('run-graph').addEventListener('click', () =&gt; this.runGraph());
        document.getElementById('stop-graph').addEventListener('click', () =&gt; this.stopGraph());
        document.getElementById('validate-graph').addEventListener('click', () =&gt; this.validateGraph());
        document.getElementById('auto-layout').addEventListener('click', () =&gt; this.autoLayout());
        document.getElementById('zoom-fit').addEventListener('click', () =&gt; this.zoomToFit());
        
        // Zoom controls
        document.getElementById('zoom-in').addEventListener('click', () =&gt; this.graphEditor.zoomIn());
        document.getElementById('zoom-out').addEventListener('click', () =&gt; this.graphEditor.zoomOut());
        
        // Graph events
        this.graphEditor.on('nodeSelected', (node) =&gt; this.selectNode(node));
        this.graphEditor.on('nodeDeselected', () =&gt; this.deselectNode());
        this.graphEditor.on('nodeAdded', (node) =&gt; this.updateStatus());
        this.graphEditor.on('nodeRemoved', (node) =&gt; this.updateStatus());
        this.graphEditor.on('connectionAdded', (connection) =&gt; this.updateStatus());
        this.graphEditor.on('connectionRemoved', (connection) =&gt; this.updateStatus());
        
        // Palette events
        this.palette.on('componentDragStart', (component) =&gt; this.handleComponentDrag(component));
        
        // Property panel events
        this.propertyPanel.on('propertyChanged', (property, value) =&gt; this.updateNodeProperty(property, value));
    }
    
    initializeComponents() {
        this.palette.loadComponents([
            // Data Operations
            { 
                name: 'Map', 
                category: 'data', 
                component: 'MapActor',
                description: 'Transform data using a function',
                icon: '🔄',
                ports: {
                    input: [{ name: 'input', type: 'any' }],
                    output: [{ name: 'output', type: 'any' }]
                }
            },
            { 
                name: 'Filter', 
                category: 'data', 
                component: 'FilterActor',
                description: 'Filter data based on conditions',
                icon: '🔍',
                ports: {
                    input: [{ name: 'input', type: 'any' }],
                    output: [{ name: 'output', type: 'any' }]
                }
            },
            { 
                name: 'Aggregate', 
                category: 'data', 
                component: 'AggregateActor',
                description: 'Aggregate multiple inputs',
                icon: '📊',
                ports: {
                    input: [{ name: 'input', type: 'any' }],
                    output: [{ name: 'output', type: 'any' }]
                }
            },
            
            // Flow Control
            { 
                name: 'Conditional', 
                category: 'flow', 
                component: 'ConditionalActor',
                description: 'Branch based on condition',
                icon: '🔀',
                ports: {
                    input: [{ name: 'input', type: 'any' }],
                    output: [
                        { name: 'true', type: 'any' },
                        { name: 'false', type: 'any' }
                    ]
                }
            },
            { 
                name: 'Merge', 
                category: 'flow', 
                component: 'MergeActor',
                description: 'Merge multiple inputs',
                icon: '🔗',
                ports: {
                    input: [
                        { name: 'input1', type: 'any' },
                        { name: 'input2', type: 'any' }
                    ],
                    output: [{ name: 'output', type: 'any' }]
                }
            },
            
            // Input/Output
            { 
                name: 'HTTP Request', 
                category: 'io', 
                component: 'HttpRequestActor',
                description: 'Make HTTP requests',
                icon: '🌐',
                ports: {
                    input: [{ name: 'url', type: 'string' }],
                    output: [
                        { name: 'response', type: 'object' },
                        { name: 'error', type: 'object' }
                    ]
                }
            },
            { 
                name: 'Logger', 
                category: 'io', 
                component: 'LoggerActor',
                description: 'Log messages',
                icon: '📝',
                ports: {
                    input: [{ name: 'message', type: 'any' }],
                    output: []
                }
            }
        ]);
        
        this.updateStatus();
    }
    
    newGraph() {
        if (this.hasUnsavedChanges()) {
            if (!confirm('You have unsaved changes. Create a new graph anyway?')) {
                return;
            }
        }
        
        this.graph = new Graph("VisualWorkflow", true, {});
        this.graphEditor.setGraph(this.graph);
        this.deselectNode();
        this.updateStatus();
        this.setStatus('New graph created');
    }
    
    async openGraph() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = async (e) =&gt; {
            const file = e.target.files[0];
            if (file) {
                try {
                    const text = await file.text();
                    const graphData = JSON.parse(text);
                    this.graph = Graph.fromJson(graphData);
                    this.graphEditor.setGraph(this.graph);
                    this.deselectNode();
                    this.updateStatus();
                    this.setStatus(`Opened: ${file.name}`);
                } catch (error) {
                    alert(`Error opening file: ${error.message}`);
                }
            }
        };
        input.click();
    }
    
    saveGraph() {
        try {
            const graphData = this.graph.toJson();
            const blob = new Blob([JSON.stringify(graphData, null, 2)], 
                                { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${this.graph.name || 'workflow'}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            this.setStatus('Graph saved');
        } catch (error) {
            alert(`Error saving graph: ${error.message}`);
        }
    }
    
    async runGraph() {
        try {
            this.setStatus('Validating graph...');
            const validation = this.graph.validate();
            
            if (!validation.isValid) {
                alert(`Graph validation failed:\n${validation.errors.join('\n')}`);
                return;
            }
            
            this.setStatus('Starting execution...');
            this.isExecuting = true;
            
            // Use Web Worker for graph execution
            if (!this.executionWorker) {
                this.executionWorker = new Worker('./workers/execution-worker.js');
                this.executionWorker.onmessage = (e) =&gt; this.handleExecutionMessage(e);
            }
            
            this.executionWorker.postMessage({
                type: 'execute',
                graph: this.graph.toJson()
            });
            
            this.updateToolbarState();
        } catch (error) {
            this.setStatus(`Execution error: ${error.message}`);
            this.isExecuting = false;
            this.updateToolbarState();
        }
    }
    
    stopGraph() {
        if (this.executionWorker) {
            this.executionWorker.postMessage({ type: 'stop' });
        }
        this.isExecuting = false;
        this.updateToolbarState();
        this.setStatus('Execution stopped');
    }
    
    validateGraph() {
        try {
            const validation = this.graph.validate();
            
            if (validation.isValid) {
                this.setStatus('Graph is valid');
                // Highlight valid state in UI
                this.graphEditor.highlightValidation(validation);
            } else {
                this.setStatus(`Validation failed: ${validation.errors.length} errors`);
                // Show validation errors in UI
                this.graphEditor.showValidationErrors(validation.errors);
                
                // Show detailed errors in console or modal
                console.log('Validation errors:', validation.errors);
            }
        } catch (error) {
            this.setStatus(`Validation error: ${error.message}`);
        }
    }
    
    autoLayout() {
        try {
            this.setStatus('Calculating layout...');
            const positions = this.graph.calculateLayout({
                algorithm: 'hierarchical',
                nodeSpacing: 120,
                layerSpacing: 80
            });
            
            this.graphEditor.animateToPositions(positions);
            this.setStatus('Layout applied');
        } catch (error) {
            this.setStatus(`Layout error: ${error.message}`);
        }
    }
    
    zoomToFit() {
        this.graphEditor.zoomToFit();
        this.setStatus('Zoomed to fit');
    }
    
    selectNode(node) {
        this.selectedNode = node;
        this.propertyPanel.showNodeProperties(node);
        this.graphEditor.highlightNode(node.id);
    }
    
    deselectNode() {
        this.selectedNode = null;
        this.propertyPanel.clear();
        this.graphEditor.clearHighlight();
    }
    
    updateNodeProperty(property, value) {
        if (this.selectedNode) {
            this.selectedNode.metadata[property] = value;
            this.graphEditor.updateNode(this.selectedNode);
            this.setStatus(`Updated ${property}`);
        }
    }
    
    handleComponentDrag(component) {
        this.graphEditor.enableDropZone(component);
    }
    
    handleExecutionMessage(e) {
        const { type, data } = e.data;
        
        switch (type) {
            case 'progress':
                this.setStatus(`Executing... ${data.progress}%`);
                this.graphEditor.updateExecutionProgress(data);
                break;
                
            case 'completed':
                this.setStatus('Execution completed successfully');
                this.isExecuting = false;
                this.updateToolbarState();
                this.graphEditor.showExecutionResults(data.results);
                break;
                
            case 'error':
                this.setStatus(`Execution failed: ${data.error}`);
                this.isExecuting = false;
                this.updateToolbarState();
                this.graphEditor.showExecutionError(data);
                break;
                
            case 'nodeExecuted':
                this.graphEditor.highlightExecutedNode(data.nodeId);
                break;
        }
    }
    
    updateStatus() {
        const nodeCount = this.graph.getNodes().length;
        const connectionCount = this.graph.getConnections().length;
        
        document.getElementById('node-count').textContent = `${nodeCount} nodes`;
        document.getElementById('connection-count').textContent = `${connectionCount} connections`;
    }
    
    updateToolbarState() {
        document.getElementById('run-graph').disabled = this.isExecuting;
        document.getElementById('stop-graph').disabled = !this.isExecuting;
    }
    
    setStatus(message) {
        document.getElementById('status-text').textContent = message;
        console.log(`Status: ${message}`);
    }
    
    hasUnsavedChanges() {
        // Implement change tracking logic
        return false;
    }
}

// Initialize application when DOM is ready
document.addEventListener('DOMContentLoaded', () =&gt; {
    new VisualEditor();
});
</code></pre>
<h3 id="3-graph-editor-component"><a class="header" href="#3-graph-editor-component">3. Graph Editor Component</a></h3>
<pre><code class="language-javascript">// src/components/Graph.js
import { EventEmitter } from '../utils/events.js';
import Node from './Node.js';
import Connection from './Connection.js';

class GraphEditor extends EventEmitter {
    constructor(graph, canvasSelector) {
        super();
        this.graph = graph;
        this.canvas = document.querySelector(canvasSelector);
        this.nodesLayer = this.canvas.querySelector('#nodes-layer');
        this.connectionsLayer = this.canvas.querySelector('#connections-layer');
        
        this.nodes = new Map();
        this.connections = new Map();
        this.scale = 1;
        this.panX = 0;
        this.panY = 0;
        
        this.dragState = null;
        this.connectionDragState = null;
        
        this.initializeEventListeners();
        this.updateView();
    }
    
    initializeEventListeners() {
        // Mouse events for panning and selection
        this.canvas.addEventListener('mousedown', (e) =&gt; this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) =&gt; this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) =&gt; this.handleMouseUp(e));
        this.canvas.addEventListener('wheel', (e) =&gt; this.handleWheel(e));
        
        // Drag and drop for components
        this.canvas.addEventListener('dragover', (e) =&gt; e.preventDefault());
        this.canvas.addEventListener('drop', (e) =&gt; this.handleDrop(e));
        
        // Keyboard events
        document.addEventListener('keydown', (e) =&gt; this.handleKeyDown(e));
    }
    
    setGraph(graph) {
        this.graph = graph;
        this.updateView();
    }
    
    updateView() {
        this.clearView();
        this.renderConnections();
        this.renderNodes();
    }
    
    clearView() {
        this.nodesLayer.innerHTML = '';
        this.connectionsLayer.innerHTML = '';
        this.nodes.clear();
        this.connections.clear();
    }
    
    renderNodes() {
        const graphNodes = this.graph.getNodes();
        
        graphNodes.forEach(nodeData =&gt; {
            const node = new Node(nodeData, this);
            this.nodes.set(nodeData.id, node);
            this.nodesLayer.appendChild(node.element);
        });
    }
    
    renderConnections() {
        const graphConnections = this.graph.getConnections();
        
        graphConnections.forEach(connectionData =&gt; {
            const connection = new Connection(connectionData, this);
            this.connections.set(connection.id, connection);
            this.connectionsLayer.appendChild(connection.element);
        });
    }
    
    addNode(componentType, position) {
        const nodeId = `node_${Date.now()}`;
        const nodeData = {
            id: nodeId,
            component: componentType.component,
            metadata: {
                x: position.x,
                y: position.y,
                label: componentType.name,
                ...componentType.defaultProperties
            }
        };
        
        this.graph.addNode(nodeId, componentType.component, nodeData.metadata);
        
        const node = new Node(nodeData, this);
        this.nodes.set(nodeId, node);
        this.nodesLayer.appendChild(node.element);
        
        this.emit('nodeAdded', nodeData);
        return node;
    }
    
    removeNode(nodeId) {
        const node = this.nodes.get(nodeId);
        if (node) {
            // Remove all connections to this node
            const connections = this.graph.getConnections()
                .filter(conn =&gt; conn.fromNode === nodeId || conn.toNode === nodeId);
            
            connections.forEach(conn =&gt; this.removeConnection(conn.id));
            
            // Remove node from graph
            this.graph.removeNode(nodeId);
            
            // Remove from UI
            node.element.remove();
            this.nodes.delete(nodeId);
            
            this.emit('nodeRemoved', { id: nodeId });
        }
    }
    
    addConnection(fromNode, fromPort, toNode, toPort) {
        try {
            const connectionId = this.graph.addConnection(fromNode, fromPort, toNode, toPort, {});
            
            const connectionData = {
                id: connectionId,
                fromNode,
                fromPort,
                toNode,
                toPort
            };
            
            const connection = new Connection(connectionData, this);
            this.connections.set(connectionId, connection);
            this.connectionsLayer.appendChild(connection.element);
            
            this.emit('connectionAdded', connectionData);
            return connection;
        } catch (error) {
            console.error('Failed to create connection:', error);
            throw error;
        }
    }
    
    removeConnection(connectionId) {
        const connection = this.connections.get(connectionId);
        if (connection) {
            this.graph.removeConnection(connectionId);
            connection.element.remove();
            this.connections.delete(connectionId);
            
            this.emit('connectionRemoved', { id: connectionId });
        }
    }
    
    getNodePosition(nodeId) {
        const node = this.nodes.get(nodeId);
        return node ? node.getPosition() : null;
    }
    
    updateNodePosition(nodeId, position) {
        const node = this.nodes.get(nodeId);
        if (node) {
            node.setPosition(position);
            this.updateConnectionsForNode(nodeId);
        }
    }
    
    updateConnectionsForNode(nodeId) {
        this.connections.forEach(connection =&gt; {
            if (connection.fromNode === nodeId || connection.toNode === nodeId) {
                connection.updatePath();
            }
        });
    }
    
    handleMouseDown(e) {
        if (e.target === this.canvas) {
            this.startPanning(e);
        }
    }
    
    handleMouseMove(e) {
        if (this.dragState?.type === 'pan') {
            this.updatePanning(e);
        } else if (this.connectionDragState) {
            this.updateConnectionDrag(e);
        }
    }
    
    handleMouseUp(e) {
        if (this.dragState?.type === 'pan') {
            this.endPanning();
        } else if (this.connectionDragState) {
            this.endConnectionDrag(e);
        }
    }
    
    handleWheel(e) {
        e.preventDefault();
        const delta = e.deltaY &gt; 0 ? 0.9 : 1.1;
        this.zoom(delta, { x: e.clientX, y: e.clientY });
    }
    
    handleDrop(e) {
        e.preventDefault();
        const componentData = JSON.parse(e.dataTransfer.getData('component'));
        const rect = this.canvas.getBoundingClientRect();
        const position = this.screenToWorld({
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        });
        
        this.addNode(componentData, position);
    }
    
    handleKeyDown(e) {
        if (e.key === 'Delete' &amp;&amp; this.selectedNode) {
            this.removeNode(this.selectedNode.id);
        }
    }
    
    startPanning(e) {
        this.dragState = {
            type: 'pan',
            startX: e.clientX,
            startY: e.clientY,
            initialPanX: this.panX,
            initialPanY: this.panY
        };
    }
    
    updatePanning(e) {
        if (this.dragState?.type === 'pan') {
            const dx = e.clientX - this.dragState.startX;
            const dy = e.clientY - this.dragState.startY;
            
            this.panX = this.dragState.initialPanX + dx;
            this.panY = this.dragState.initialPanY + dy;
            
            this.updateTransform();
        }
    }
    
    endPanning() {
        this.dragState = null;
    }
    
    startConnectionDrag(fromNode, fromPort, startPosition) {
        this.connectionDragState = {
            fromNode,
            fromPort,
            startPosition,
            currentPosition: startPosition
        };
        
        // Create temporary connection line
        this.createTempConnectionLine();
    }
    
    updateConnectionDrag(e) {
        if (this.connectionDragState) {
            const rect = this.canvas.getBoundingClientRect();
            this.connectionDragState.currentPosition = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            this.updateTempConnectionLine();
        }
    }
    
    endConnectionDrag(e) {
        if (this.connectionDragState) {
            // Find target node and port
            const target = this.findConnectionTarget(e);
            
            if (target) {
                try {
                    this.addConnection(
                        this.connectionDragState.fromNode,
                        this.connectionDragState.fromPort,
                        target.nodeId,
                        target.portName
                    );
                } catch (error) {
                    console.error('Connection failed:', error);
                }
            }
            
            this.removeTempConnectionLine();
            this.connectionDragState = null;
        }
    }
    
    zoom(factor, center) {
        const newScale = Math.max(0.1, Math.min(3, this.scale * factor));
        
        if (center) {
            const worldCenter = this.screenToWorld(center);
            this.scale = newScale;
            const newScreenCenter = this.worldToScreen(worldCenter);
            
            this.panX += center.x - newScreenCenter.x;
            this.panY += center.y - newScreenCenter.y;
        } else {
            this.scale = newScale;
        }
        
        this.updateTransform();
        this.updateZoomDisplay();
    }
    
    zoomIn() {
        this.zoom(1.2);
    }
    
    zoomOut() {
        this.zoom(0.8);
    }
    
    zoomToFit() {
        if (this.nodes.size === 0) return;
        
        // Calculate bounding box of all nodes
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        this.nodes.forEach(node =&gt; {
            const pos = node.getPosition();
            minX = Math.min(minX, pos.x);
            minY = Math.min(minY, pos.y);
            maxX = Math.max(maxX, pos.x + 120); // Node width
            maxY = Math.max(maxY, pos.y + 80);  // Node height
        });
        
        const padding = 50;
        const contentWidth = maxX - minX + 2 * padding;
        const contentHeight = maxY - minY + 2 * padding;
        
        const canvasRect = this.canvas.getBoundingClientRect();
        const scaleX = canvasRect.width / contentWidth;
        const scaleY = canvasRect.height / contentHeight;
        
        this.scale = Math.min(scaleX, scaleY, 1);
        this.panX = (canvasRect.width - contentWidth * this.scale) / 2 - (minX - padding) * this.scale;
        this.panY = (canvasRect.height - contentHeight * this.scale) / 2 - (minY - padding) * this.scale;
        
        this.updateTransform();
        this.updateZoomDisplay();
    }
    
    updateTransform() {
        const transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.scale})`;
        this.nodesLayer.style.transform = transform;
        this.connectionsLayer.style.transform = transform;
    }
    
    updateZoomDisplay() {
        const zoomPercent = Math.round(this.scale * 100);
        document.getElementById('zoom-level').textContent = `${zoomPercent}%`;
    }
    
    screenToWorld(screenPos) {
        return {
            x: (screenPos.x - this.panX) / this.scale,
            y: (screenPos.y - this.panY) / this.scale
        };
    }
    
    worldToScreen(worldPos) {
        return {
            x: worldPos.x * this.scale + this.panX,
            y: worldPos.y * this.scale + this.panY
        };
    }
    
    // Additional methods for animations, validation display, etc.
    animateToPositions
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../scripting/javascript/deno-runtime.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tutorials/reactflow-reflow-integration.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../scripting/javascript/deno-runtime.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tutorials/reactflow-reflow-integration.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
